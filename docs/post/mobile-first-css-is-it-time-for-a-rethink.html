<!DOCTYPE html><html><head><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mobile-First CSS: Is It Time for a Rethink?</title><meta name="next-head-count" content="3"/><link rel="preload" href="./_next/static/css/79ff677694a359998c6d.css" as="style"/><link rel="stylesheet" href="./_next/static/css/79ff677694a359998c6d.css" data-n-g=""/><link rel="preload" href="./_next/static/css/9a669cc450b6f648da47.css" as="style"/><link rel="stylesheet" href="./_next/static/css/9a669cc450b6f648da47.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="./_next/static/chunks/main-c0f2b50e9938076e09f9.js" as="script"/><link rel="preload" href="./_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="./_next/static/chunks/framework.0a9f20eff0752717cd72.js" as="script"/><link rel="preload" href="./_next/static/chunks/commons.7e51f7faca0d1c02960a.js" as="script"/><link rel="preload" href="./_next/static/chunks/pages/_app-278c45bd34167c703d71.js" as="script"/><link rel="preload" href="./_next/static/chunks/1bfc9850.bc0f97e669058583e58f.js" as="script"/><link rel="preload" href="./_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.34679e387e2768d6eefe.js" as="script"/><link rel="preload" href="./_next/static/chunks/pages/post/%5Bslug%5D-4fef356bf27346a51326.js" as="script"/></head><body><div id="__next"><div class="post_container__3BS1P"><a href="/"><header class="header_postHeader__32sXm"><img src="/Logo.svg" alt="logo"/></header></a><img src="https://images.prismic.io/spacetravelingac/42bab0e0-bf47-46b4-8d07-3cf826263f35_mobile-first-css-time-for-a-rethink.webp?auto=compress,format" alt="Post Banner" class="post_postBanner__1vH8j"/><main><article style="display:flex;flex-direction:column;align-items:center"><div class="post_title__3tPRa"><strong>Mobile-First CSS: Is It Time for a Rethink?</strong><p class="common_postInfoContainer__3xJzO"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time>23 set 2022</time><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></svg><span>Patrick Clancey</span><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span>5 min</span></p></div><div class="post_postContainer__1DkNP"><strong>The mobile-first design methodology is great—it focuses on what really matters to the user, it’s well-practiced, and it’s been a common design pattern for years. So developing your CSS mobile-first should also be great, too…right?</strong><div><p>Well, not necessarily. Classic mobile-first CSS development is based on the principle of overwriting style declarations: you begin your CSS with default style declarations, and overwrite and/or add new styles as you add breakpoints with min-width media queries for larger viewports (for a good overview see “<a  href="https://www.mightyminnow.com/2013/11/what-is-mobile-first-css-and-why-does-it-rock/">What is Mobile First CSS and Why Does It Rock?</a>”). But all those exceptions create complexity and inefficiency, which in turn can lead to an increased testing effort and a code base that’s harder to maintain. Admit it—how many of us willingly want that?</p><p>On your own projects, mobile-first CSS may yet be the best tool for the job, but first you need to evaluate just how appropriate it is in light of the visual design and user interactions you’re working on. To help you get started, here’s how I go about tackling the factors you need to watch for, and I’ll discuss some alternate solutions if mobile-first doesn’t seem to suit your project.</p></div></div><div class="post_postContainer__1DkNP"><strong>Advantages of mobile-first</strong><div><p>Some of the things to like with mobile-first CSS development—and why it’s been the de facto development methodology for so long—make a lot of sense:</p><p><strong>Development hierarchy. </strong>One thing you undoubtedly get from mobile-first is a nice development hierarchy—you just focus on the mobile view and get developing. </p><p><strong>Tried and tested. </strong>It’s a tried and tested methodology that’s worked for years for a reason: it solves a problem really well.</p><p><strong>Prioritizes the mobile view</strong>. The mobile view is the<strong> </strong>simplest<strong> </strong>and arguably the most important, as it <strong>encompasses all the key user journeys</strong>, and often accounts for a <strong>higher proportion of user visits</strong> (depending on the project). </p><p><strong>Prevents desktop-centric development. </strong>As development is done using desktop computers, it can be tempting to initially focus on the desktop view. But thinking about mobile from the start prevents us from getting stuck later on; no one wants to spend their time retrofitting a desktop-centric site to work on mobile devices!</p></div></div><div class="post_postContainer__1DkNP"><strong>Disadvantages of mobile-first</strong><div><p>Setting style declarations and then overwriting them at higher breakpoints can lead to undesirable ramifications:</p><p><strong>More complexity. </strong>The farther up the breakpoint hierarchy you go, the more unnecessary code you inherit from lower breakpoints. </p><p><strong>Higher CSS specificity. </strong>Styles that have been reverted to their browser default value in a class name declaration now have a higher specificity. This can be a headache on large projects when you want to keep the CSS selectors as simple as possible.</p><p><strong>Requires more regression testing. </strong>Changes to the CSS at a lower view (like adding a new style) requires all higher breakpoints to be regression tested.</p><p><strong>The browser can’t prioritize CSS downloads. </strong>At wider breakpoints, classic mobile-first min-width media queries don’t leverage the browser’s capability to download CSS files in priority order.</p></div></div><div class="post_postContainer__1DkNP"><strong>The problem of property value overrides</strong><div><p>There is nothing inherently wrong with overwriting values; CSS was designed to do just that. Still, inheriting incorrect values is unhelpful and can be burdensome and inefficient. It can also lead to increased style specificity when you have to overwrite styles to reset them back to their defaults, something that may cause issues later on, especially if you are using a combination of bespoke CSS and utility classes. We won’t be able to use a utility class for a style that has been reset with a higher specificity.</p><p>With this in mind, I’m developing CSS with a focus on the default values much more these days. Since there’s no specific order, and no chains of specific values to keep track of, this frees me to develop breakpoints <em>simultaneously</em>. I concentrate on finding common styles and isolating the specific exceptions in closed media query ranges (that is, any range with a max-width set). </p><p>This approach opens up some opportunities, as you can look at each breakpoint as a clean slate. If a component’s layout looks like it should be based on Flexbox at all breakpoints, it’s fine and can be coded in the default style sheet. But if it looks like Grid would be much better for large screens and Flexbox for mobile, these can both be done entirely independently when the CSS is put into closed media query ranges. Also, developing simultaneously requires you to have a good understanding of any given component in all breakpoints up front. This can help surface issues in the design earlier in the development process. We don’t want to get stuck down a rabbit hole building a complex component for mobile, and then get the designs for desktop and find they are equally complex and incompatible with the HTML we created for the mobile view! </p><p>Though this approach isn’t going to suit everyone, I encourage you to give it a try. There are plenty of tools out there to help with concurrent development, such as <a  href="https://responsively.app/">Responsively App</a>, <a  href="https://blisk.io/">Blisk</a>, and many others. </p><p>Having said that, I don’t feel the order itself is particularly relevant. If you are comfortable with focusing on the mobile view, have a good understanding of the requirements for other breakpoints, and prefer to work on one device at a time, then by all means stick with the classic development order. The important thing is to identify common styles and exceptions so you can put them in the relevant stylesheet—a sort of manual tree-shaking process! Personally, I find this a little easier when working on a component across breakpoints, but that’s by no means a requirement.</p></div></div><div class="post_postContainer__1DkNP"><strong></strong><div><p>In classic mobile-first CSS we overwrite the styles, but we can avoid this by using media query ranges. To illustrate the difference (I’m using SCSS for brevity), let’s assume there are three visual designs: </p><ul><li>smaller than 768</li><li>from 768 to below 1024</li><li>1024 and anything larger </li></ul><p>Take a simple example where a block-level element has a default padding of “20px,” which is overwritten at tablet to be “40px” and set back to “20px” on desktop.</p>
    <p class=" block-img">
      <img src="https://images.prismic.io/spacetravelingac/38c9555a-cdb0-4814-b498-f2e4e0dc4c3a_Screenshot+from+2022-09-23+12-33-11.png?auto=compress,format" alt="Code sample" copyright="" />
    </p>
  <p>The subtle difference is that the mobile-first example sets the default padding to “20px” and then overwrites it at each breakpoint, setting it three times in total. In contrast, the second example sets the default padding to “20px” and only overrides it at the relevant breakpoint where it isn’t the default value (in this instance, tablet is the exception).</p><p>The goal is to: </p><ul><li>Only set styles when needed. </li><li>Not set them with the <em>expectation</em> of overwriting them later on, again and again. </li></ul><p>To this end, closed media query ranges are our best friend. If we need to make a change to any given view, we make it in the CSS media query range that applies to the specific breakpoint. We’ll be much less likely to introduce unwanted alterations, and our regression testing only needs to focus on the breakpoint we have actually edited. </p><p>Taking the above example, if we find that .my-block spacing on desktop is already accounted for by the margin at that breakpoint, and since we want to remove the padding altogether, we could do this by setting the mobile padding in a closed media query range.</p><p>The browser default padding for our block is “0,” so instead of adding a desktop media query and using unset or “0” for the padding value (which we would need with mobile-first), we can wrap the mobile padding in a closed media query (since it is now also an exception) so it won’t get picked up at wider breakpoints. At the desktop breakpoint, we won’t need to set any padding style, as we want the browser default value.</p><p></p><p></p><p></p></div></div></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"Yy3SthMAAILYNZ4W","uid":"mobile-first-css-is-it-time-for-a-rethink","url":null,"type":"posts","href":"https://spacetravelingac.cdn.prismic.io/api/v2/documents/search?ref=Yy3SuxMAACUANZ4w\u0026q=%5B%5B%3Ad+%3D+at%28document.id%2C+%22Yy3SthMAAILYNZ4W%22%29+%5D%5D","tags":[],"first_publication_date":"2022-09-23T15:37:31+0000","last_publication_date":"2022-09-23T15:37:31+0000","slugs":["mobile-first-css-is-it-time-for-a-rethink"],"linked_documents":[],"lang":"pt-br","alternate_languages":[],"data":{"title":"Mobile-First CSS: Is It Time for a Rethink?","subtitle":"The mobile-first design methodology is great—it focuses on what really matters to the user, it’s well-practiced, and it’s been a common design pattern for years. So developing your CSS mobile-first should also be great, too…right?","author":"Patrick Clancey","image":{"dimensions":{"width":1500,"height":940},"alt":"Octopus Cooking","copyright":null,"url":"https://images.prismic.io/spacetravelingac/42bab0e0-bf47-46b4-8d07-3cf826263f35_mobile-first-css-time-for-a-rethink.webp?auto=compress,format"},"content":[{"heading":"The mobile-first design methodology is great—it focuses on what really matters to the user, it’s well-practiced, and it’s been a common design pattern for years. So developing your CSS mobile-first should also be great, too…right?","body":[{"type":"paragraph","text":"Well, not necessarily. Classic mobile-first CSS development is based on the principle of overwriting style declarations: you begin your CSS with default style declarations, and overwrite and/or add new styles as you add breakpoints with min-width media queries for larger viewports (for a good overview see “What is Mobile First CSS and Why Does It Rock?”). But all those exceptions create complexity and inefficiency, which in turn can lead to an increased testing effort and a code base that’s harder to maintain. Admit it—how many of us willingly want that?","spans":[{"start":308,"end":354,"type":"hyperlink","data":{"link_type":"Web","url":"https://www.mightyminnow.com/2013/11/what-is-mobile-first-css-and-why-does-it-rock/"}}]},{"type":"paragraph","text":"On your own projects, mobile-first CSS may yet be the best tool for the job, but first you need to evaluate just how appropriate it is in light of the visual design and user interactions you’re working on. To help you get started, here’s how I go about tackling the factors you need to watch for, and I’ll discuss some alternate solutions if mobile-first doesn’t seem to suit your project.","spans":[]}]},{"heading":"Advantages of mobile-first","body":[{"type":"paragraph","text":"Some of the things to like with mobile-first CSS development—and why it’s been the de facto development methodology for so long—make a lot of sense:","spans":[]},{"type":"paragraph","text":"Development hierarchy. One thing you undoubtedly get from mobile-first is a nice development hierarchy—you just focus on the mobile view and get developing. ","spans":[{"start":0,"end":23,"type":"strong"}]},{"type":"paragraph","text":"Tried and tested. It’s a tried and tested methodology that’s worked for years for a reason: it solves a problem really well.","spans":[{"start":0,"end":18,"type":"strong"}]},{"type":"paragraph","text":"Prioritizes the mobile view. The mobile view is the simplest and arguably the most important, as it encompasses all the key user journeys, and often accounts for a higher proportion of user visits (depending on the project). ","spans":[{"start":0,"end":27,"type":"strong"},{"start":51,"end":52,"type":"strong"},{"start":60,"end":61,"type":"strong"},{"start":100,"end":137,"type":"strong"},{"start":164,"end":196,"type":"strong"}]},{"type":"paragraph","text":"Prevents desktop-centric development. As development is done using desktop computers, it can be tempting to initially focus on the desktop view. But thinking about mobile from the start prevents us from getting stuck later on; no one wants to spend their time retrofitting a desktop-centric site to work on mobile devices!","spans":[{"start":0,"end":38,"type":"strong"}]}]},{"heading":"Disadvantages of mobile-first","body":[{"type":"paragraph","text":"Setting style declarations and then overwriting them at higher breakpoints can lead to undesirable ramifications:","spans":[]},{"type":"paragraph","text":"More complexity. The farther up the breakpoint hierarchy you go, the more unnecessary code you inherit from lower breakpoints. ","spans":[{"start":0,"end":17,"type":"strong"}]},{"type":"paragraph","text":"Higher CSS specificity. Styles that have been reverted to their browser default value in a class name declaration now have a higher specificity. This can be a headache on large projects when you want to keep the CSS selectors as simple as possible.","spans":[{"start":0,"end":24,"type":"strong"}]},{"type":"paragraph","text":"Requires more regression testing. Changes to the CSS at a lower view (like adding a new style) requires all higher breakpoints to be regression tested.","spans":[{"start":0,"end":34,"type":"strong"}]},{"type":"paragraph","text":"The browser can’t prioritize CSS downloads. At wider breakpoints, classic mobile-first min-width media queries don’t leverage the browser’s capability to download CSS files in priority order.","spans":[{"start":0,"end":44,"type":"strong"}]}]},{"heading":"The problem of property value overrides","body":[{"type":"paragraph","text":"There is nothing inherently wrong with overwriting values; CSS was designed to do just that. Still, inheriting incorrect values is unhelpful and can be burdensome and inefficient. It can also lead to increased style specificity when you have to overwrite styles to reset them back to their defaults, something that may cause issues later on, especially if you are using a combination of bespoke CSS and utility classes. We won’t be able to use a utility class for a style that has been reset with a higher specificity.","spans":[]},{"type":"paragraph","text":"With this in mind, I’m developing CSS with a focus on the default values much more these days. Since there’s no specific order, and no chains of specific values to keep track of, this frees me to develop breakpoints simultaneously. I concentrate on finding common styles and isolating the specific exceptions in closed media query ranges (that is, any range with a max-width set). ","spans":[{"start":216,"end":230,"type":"em"}]},{"type":"paragraph","text":"This approach opens up some opportunities, as you can look at each breakpoint as a clean slate. If a component’s layout looks like it should be based on Flexbox at all breakpoints, it’s fine and can be coded in the default style sheet. But if it looks like Grid would be much better for large screens and Flexbox for mobile, these can both be done entirely independently when the CSS is put into closed media query ranges. Also, developing simultaneously requires you to have a good understanding of any given component in all breakpoints up front. This can help surface issues in the design earlier in the development process. We don’t want to get stuck down a rabbit hole building a complex component for mobile, and then get the designs for desktop and find they are equally complex and incompatible with the HTML we created for the mobile view! ","spans":[]},{"type":"paragraph","text":"Though this approach isn’t going to suit everyone, I encourage you to give it a try. There are plenty of tools out there to help with concurrent development, such as Responsively App, Blisk, and many others. ","spans":[{"start":166,"end":182,"type":"hyperlink","data":{"link_type":"Web","url":"https://responsively.app/"}},{"start":184,"end":189,"type":"hyperlink","data":{"link_type":"Web","url":"https://blisk.io/"}}]},{"type":"paragraph","text":"Having said that, I don’t feel the order itself is particularly relevant. If you are comfortable with focusing on the mobile view, have a good understanding of the requirements for other breakpoints, and prefer to work on one device at a time, then by all means stick with the classic development order. The important thing is to identify common styles and exceptions so you can put them in the relevant stylesheet—a sort of manual tree-shaking process! Personally, I find this a little easier when working on a component across breakpoints, but that’s by no means a requirement.","spans":[]}]},{"heading":null,"body":[{"type":"paragraph","text":"In classic mobile-first CSS we overwrite the styles, but we can avoid this by using media query ranges. To illustrate the difference (I’m using SCSS for brevity), let’s assume there are three visual designs: ","spans":[]},{"type":"list-item","text":"smaller than 768","spans":[]},{"type":"list-item","text":"from 768 to below 1024","spans":[]},{"type":"list-item","text":"1024 and anything larger ","spans":[]},{"type":"paragraph","text":"Take a simple example where a block-level element has a default padding of “20px,” which is overwritten at tablet to be “40px” and set back to “20px” on desktop.","spans":[]},{"type":"image","url":"https://images.prismic.io/spacetravelingac/38c9555a-cdb0-4814-b498-f2e4e0dc4c3a_Screenshot+from+2022-09-23+12-33-11.png?auto=compress,format","alt":"Code sample","copyright":null,"dimensions":{"width":781,"height":577}},{"type":"paragraph","text":"The subtle difference is that the mobile-first example sets the default padding to “20px” and then overwrites it at each breakpoint, setting it three times in total. In contrast, the second example sets the default padding to “20px” and only overrides it at the relevant breakpoint where it isn’t the default value (in this instance, tablet is the exception).","spans":[]},{"type":"paragraph","text":"The goal is to: ","spans":[]},{"type":"list-item","text":"Only set styles when needed. ","spans":[]},{"type":"list-item","text":"Not set them with the expectation of overwriting them later on, again and again. ","spans":[{"start":22,"end":33,"type":"em"}]},{"type":"paragraph","text":"To this end, closed media query ranges are our best friend. If we need to make a change to any given view, we make it in the CSS media query range that applies to the specific breakpoint. We’ll be much less likely to introduce unwanted alterations, and our regression testing only needs to focus on the breakpoint we have actually edited. ","spans":[]},{"type":"paragraph","text":"Taking the above example, if we find that .my-block spacing on desktop is already accounted for by the margin at that breakpoint, and since we want to remove the padding altogether, we could do this by setting the mobile padding in a closed media query range.","spans":[]},{"type":"paragraph","text":"The browser default padding for our block is “0,” so instead of adding a desktop media query and using unset or “0” for the padding value (which we would need with mobile-first), we can wrap the mobile padding in a closed media query (since it is now also an exception) so it won’t get picked up at wider breakpoints. At the desktop breakpoint, we won’t need to set any padding style, as we want the browser default value.","spans":[]},{"type":"paragraph","text":"","spans":[]},{"type":"paragraph","text":"","spans":[]},{"type":"paragraph","text":"","spans":[]}]}]}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"mobile-first-css-is-it-time-for-a-rethink"},"buildId":"YMp5jpApzeTd4ZqLqp-Bc","assetPrefix":".","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="./_next/static/chunks/polyfills-144e5fa6fafab6397d9c.js"></script><script src="./_next/static/chunks/main-c0f2b50e9938076e09f9.js" async=""></script><script src="./_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="./_next/static/chunks/framework.0a9f20eff0752717cd72.js" async=""></script><script src="./_next/static/chunks/commons.7e51f7faca0d1c02960a.js" async=""></script><script src="./_next/static/chunks/pages/_app-278c45bd34167c703d71.js" async=""></script><script src="./_next/static/chunks/1bfc9850.bc0f97e669058583e58f.js" async=""></script><script src="./_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.34679e387e2768d6eefe.js" async=""></script><script src="./_next/static/chunks/pages/post/%5Bslug%5D-4fef356bf27346a51326.js" async=""></script><script src="./_next/static/YMp5jpApzeTd4ZqLqp-Bc/_buildManifest.js" async=""></script><script src="./_next/static/YMp5jpApzeTd4ZqLqp-Bc/_ssgManifest.js" async=""></script></body></html>